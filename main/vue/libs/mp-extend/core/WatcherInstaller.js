import OptionInstaller from"./OptionInstaller";import{Invocation}from"../libs/Invocation";import{isFunction,isNullOrEmpty,isPlainObject,isString}from"../utils/common";import{Collectors,Stream}from"../libs/Stream";const ARR_REG=/([\w\$]+)\[(\d+)\]/;class CompatibleWatcher{_oldValue=[];_callback=void 0;_immediate=!1;_deep=!1;_path="";constructor(e,t,i,s,a=[]){this._callback=t,this._immediate=i,this._deep=s,this._path=e,this._oldValue=a}call(e,t){this._callback&&this._callback.apply(e,t.concat(this._oldValue||[])),this._oldValue=t}get immediate(){return this._immediate}set immediate(e){this._immediate=e}get deep(){return this._deep}set deep(e){this._deep=e}get path(){return this._path}set path(e){this._path=e}get oldValue(){return this._oldValue}set oldValue(e){this._oldValue=e}}class OnceCompatibleWatcher extends CompatibleWatcher{_queue=[];_emitted=!1;_immediateWatchers=void 0;constructor(e,t,i=void 0){super(t,i,!0,!1,[]),this._queue=e,this._immediateWatchers=e.filter(e=>e.immediate)}call(e,t){!1===this._emitted&&(super.call(e,t),this._emitted=!0)}run(t,i=[]){this._immediateWatchers&&this._immediateWatchers.length&&this._immediateWatchers.forEach(function(e){e.call(t,i)})}release(){this._queue.splice(this._queue.indexOf(this),1),this._queue=null}get emitted(){return this._emitted}}function collectObservers(t,e,i,s,a,l=new Map){let r=l.get(t);if(r||(r=[],l.set(t,r)),isFunction(e))r.push(new CompatibleWatcher(t,e,i,s));else if(isString(e))r.push(new CompatibleWatcher(t,function(){isFunction(this[e])&&this[e].apply(this,arguments)},i,s));else if(isPlainObject(e)){const{deep:s=!1,immediate:i=!1}=e;!0===s?collectObservers(t+".**",e.handler,i,!1,a,l):collectObservers(t,e.handler,i,!1,a,l)}else Array.isArray(e)&&e.forEach(e=>{collectObservers(t,e,i,s,a,l)})}export default class WatcherInstaller extends OptionInstaller{_observers={};watch(e,t,i){}dynamicObserver(){}selectData(e,t){var i=t.indexOf("."),s=i<0?t:t.substring(0,i);if(0<i)return this.selectData(e[s],t.substring(i+1));if("**"===s)return e;if(ARR_REG.test(s)){var[,t,i]=ARR_REG.exec(s);return e[t][parseInt(i)]}return e[s]}selectMultiData(t,e=[]){return isNullOrEmpty(t)?[]:e.map(e=>this.selectData(t,e))}definitionFilter(e,t,i,s,a){const l=t.get("observers")||{},r=t.get("watch");var c=t.get("data"),t=t.get("properties");const n=this,o=this.createInitializationCompatibleContext(c,t,null);Object.assign(l,Object.hasOwnProperty.call(l,"**")?{"**":Invocation(l["**"],this.dynamicObserver)}:{"**":this.dynamicObserver});const h=Object.keys(r).filter(e=>"**"!==e);if(0<h.length){const m=new Map;h.forEach(e=>{collectObservers(e,r[e],!1,!1,o,m)});const u=[];Object.assign.apply(void 0,[l,Stream.of([...m]).filter(([,e])=>0<e.length).map(([e,i])=>{const t=n.selectMultiData(o,e.split(","));var s=new OnceCompatibleWatcher(i,e,function(){i.forEach(e=>{e.oldValue=t})});i.unshift(s),u.push(s);const a=l[e];return[e,function(...t){isFunction(a)&&a.call(this,t),i.forEach(e=>{e.call(this,t)})}]}).collect(Collectors.toMap())]),Object.assign(s,{behaviors:(s.behaviors||[]).concat(Behavior({lifetimes:{attached(){const i=n.createRuntimeCompatibleContext(this);u.filter(e=>!1===e.emitted).forEach(e=>{var t;!e.path||(t=e.path.split(",")).length&&(t=n.selectMultiData(i,t),e.run(this,t),e.call(this,t))}),u.splice(0).forEach(e=>e.release())}}}))})}Object.assign(s,{observers:l})}install(e,t,i){var{observers:s=null}=i;t.set("observers",Object.assign.apply(void 0,[this._observers,...e.installers.map(e=>e.observers()),s])),t.set("watch",i.watch||{})}}