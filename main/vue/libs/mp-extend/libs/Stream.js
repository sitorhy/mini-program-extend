const Collectors={toList:function(){return r=>[...r]},toMap:function(...r){let n=r=>r[0],e=r=>r[1],u=!1;return 1===r.length&&!0===r[0]?u=!0:3<=r.length&&(n=r[0],e=r[1],u=Boolean(r[2])),(r=[])=>{let t;return u?(t=new Map,r.forEach(r=>t.set(n(r),e(r)))):(t={},r.forEach(r=>t[n(r)]=e(r))),t}},toSet:function(){return r=>new Set(r)},reducing:function(t,n){return r=>r.reduce(t,n)},counting:function(){return r=>r.length},maxBy:function(u=()=>0){return n=>{let e=n[0];return n.forEach((r,t)=>{0<t&&0<u(n[t-1],n[t])&&(e=r)}),e}},minBy:function(u=()=>0){return n=>{let e=n[0];return n.forEach((r,t)=>{0<t&&u(n[t-1],n[t])<0&&(e=r)}),e}},joining:function(t){return r=>r.join(t)},groupingBy:function(e,u=!1){return r=>this.reducing((r,t)=>{var n=e(t);return u?r.has(n)?r.get(n).push(t):r.set(n,[t]):Object.hasOwnProperty.call(r,n)?r[n].push(t):r[n]=[t],r},u?new Map:{})(r)}};class Stream{static of(r=[]){return new Stream(r)}constructor(r=[]){this.arr=r}flat(){return this.arr.reduce((r,t)=>Array.isArray(t)?r.concat(t):(r.push(t),r),[])}flatMap(r=r=>r){return Stream.of(this.arr.map(r)).flat()}map(r=r=>r){return Stream.of(this.arr.map(r))}collect(r){return"function"==typeof r?r(this.arr):null}distinct(){return Stream.of([...new Set([...this.arr])])}filter(r=()=>!0){return Stream.of(this.arr.filter(r))}}export{Collectors,Stream};